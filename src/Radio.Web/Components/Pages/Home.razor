@page "/"
@rendermode InteractiveServer
@inject AudioApiService AudioApi
@inject AudioStateHubService HubService
@implements IAsyncDisposable

<PageTitle>Now Playing - Radio Console</PageTitle>

<div class="home-page" style="padding: 24px; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center;">
  <!-- Now Playing Display -->
  <MudCard Elevation="2" Style="width: 100%; max-width: 800px; padding: 32px;">
    <MudCardContent>
      <div style="text-align: center;">
        <!-- Album Art or Generic Icon -->
        <div style="margin-bottom: 24px;">
          @if (string.IsNullOrEmpty(_albumArtUrl))
          {
            <MudIcon Icon="@Icons.Material.Filled.MusicNote" Style="font-size: 200px; color: var(--text-secondary);" />
          }
          else
          {
            <img src="@_albumArtUrl" alt="Album Art" style="width: 400px; height: 400px; object-fit: cover; border-radius: 8px;" />
          }
        </div>
        
        <!-- Track Info -->
        <MudText Typo="Typo.h3" Style="font-weight: 600; margin-bottom: 8px;">
          @(_title ?? "No Track Playing")
        </MudText>
        <MudText Typo="Typo.h5" Style="margin-bottom: 4px; color: var(--text-secondary);">
          @(_artist ?? "--")
        </MudText>
        <MudText Typo="Typo.h6" Style="color: var(--text-tertiary);">
          @(_album ?? "--")
        </MudText>
        
        <!-- Source Badge -->
        @if (!string.IsNullOrEmpty(_source))
        {
          <MudChip T="string" Color="Color.Primary" Style="margin-top: 16px;">@_source</MudChip>
        }
      </div>
    </MudCardContent>
  </MudCard>
  
  <!-- Transport Controls -->
  <div style="margin-top: 32px; display: flex; gap: 16px; align-items: center;">
    <MudIconButton Icon="@Icons.Material.Filled.Shuffle" 
                   Color="@(_isShuffleEnabled ? Color.Primary : Color.Default)" 
                   Size="Size.Large"
                   Style="min-width: 60px; min-height: 60px;"
                   OnClick="HandleShuffleAsync"
                   title="Shuffle" />
    
    <MudIconButton Icon="@Icons.Material.Filled.SkipPrevious" 
                   Color="Color.Default" 
                   Size="Size.Large"
                   Style="min-width: 60px; min-height: 60px;"
                   OnClick="HandlePreviousAsync"
                   title="Previous" />
    
    <MudIconButton Icon="@(_isPlaying ? Icons.Material.Filled.Pause : Icons.Material.Filled.PlayArrow)" 
                   Color="Color.Primary" 
                   Size="Size.Large"
                   Style="min-width: 80px; min-height: 80px; font-size: 48px;"
                   Class="primary-action"
                   OnClick="HandlePlayPauseAsync"
                   title="@(_isPlaying ? "Pause" : "Play")" />
    
    <MudIconButton Icon="@Icons.Material.Filled.SkipNext" 
                   Color="Color.Default" 
                   Size="Size.Large"
                   Style="min-width: 60px; min-height: 60px;"
                   OnClick="HandleNextAsync"
                   title="Next" />
    
    <MudIconButton Icon="@Icons.Material.Filled.Repeat" 
                   Color="@(_repeatMode != "Off" ? Color.Primary : Color.Default)" 
                   Size="Size.Large"
                   Style="min-width: 60px; min-height: 60px;"
                   OnClick="HandleRepeatAsync"
                   title="@($"Repeat: {_repeatMode}")" />
  </div>
  
  <!-- Volume Control -->
  <div style="margin-top: 32px; width: 100%; max-width: 500px;">
    <div style="display: flex; align-items: center; gap: 16px;">
      <MudIconButton Icon="@(_isMuted ? Icons.Material.Filled.VolumeOff : Icons.Material.Filled.VolumeUp)" 
                     Color="Color.Default" 
                     OnClick="HandleMuteAsync"
                     title="@(_isMuted ? "Unmute" : "Mute")" />
      <MudSlider Value="_volume" ValueChanged="@((double v) => OnVolumeChanged(v))" Min="0" Max="1" Step="0.01" Style="flex: 1;" Color="Color.Primary">
        Volume: @((_volume * 100).ToString("F0"))%
      </MudSlider>
    </div>
  </div>
</div>

@code {
  private bool _isPlaying = false;
  private bool _isMuted = false;
  private bool _isShuffleEnabled = false;
  private string _repeatMode = "Off";
  private double _volume = 0.75;
  private string? _title = null;
  private string? _artist = null;
  private string? _album = null;
  private string? _albumArtUrl = null;
  private string? _source = null;
  private System.Threading.Timer? _timer;

  protected override async Task OnInitializedAsync()
  {
    // Subscribe to SignalR events for real-time updates
    HubService.PlaybackStateChanged += OnPlaybackStateChanged;
    HubService.NowPlayingChanged += OnNowPlayingChanged;
    HubService.VolumeChanged += OnVolumeChanged;

    // Start SignalR connection if not already connected
    if (!HubService.IsConnected)
    {
      try
      {
        await HubService.StartAsync();
      }
      catch (Exception ex)
      {
        // Log error but continue with polling fallback
        Console.WriteLine($"Failed to connect to SignalR: {ex.Message}");
      }
    }

    // Initial load
    await RefreshPlaybackStateAsync();
    
    // Fallback polling every 5 seconds if SignalR is disconnected
    _timer = new System.Threading.Timer(async _ =>
    {
      if (!HubService.IsConnected)
      {
        await RefreshPlaybackStateAsync();
        await InvokeAsync(StateHasChanged);
      }
    }, null, TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(5));
  }

  private async Task OnPlaybackStateChanged()
  {
    await RefreshPlaybackStateAsync();
    await InvokeAsync(StateHasChanged);
  }

  private async Task OnNowPlayingChanged()
  {
    await RefreshPlaybackStateAsync();
    await InvokeAsync(StateHasChanged);
  }

  private async Task OnVolumeChanged()
  {
    await RefreshPlaybackStateAsync();
    await InvokeAsync(StateHasChanged);
  }

  private async Task RefreshPlaybackStateAsync()
  {
    try
    {
      var state = await AudioApi.GetPlaybackStateAsync();
      if (state != null)
      {
        _isPlaying = state.IsPlaying;
        _isMuted = state.IsMuted;
        _isShuffleEnabled = state.IsShuffleEnabled;
        _repeatMode = state.RepeatMode;
        _volume = state.Volume;
      }

      var nowPlaying = await AudioApi.GetNowPlayingAsync();
      if (nowPlaying != null)
      {
        _title = nowPlaying.Title;
        _artist = nowPlaying.Artist;
        _album = nowPlaying.Album;
        _albumArtUrl = nowPlaying.AlbumArtUrl;
        _source = nowPlaying.Source;
      }
    }
    catch (Exception)
    {
      // Silently fail to avoid disrupting UI updates
    }
  }

  private async Task HandlePlayPauseAsync()
  {
    if (_isPlaying)
    {
      await AudioApi.UpdatePlaybackStateAsync(new UpdatePlaybackRequest("pause", null, null, null));
    }
    else
    {
      await AudioApi.StartAsync();
    }
    await RefreshPlaybackStateAsync();
  }

  private async Task HandleNextAsync()
  {
    await AudioApi.NextAsync();
    await RefreshPlaybackStateAsync();
  }

  private async Task HandlePreviousAsync()
  {
    await AudioApi.PreviousAsync();
    await RefreshPlaybackStateAsync();
  }

  private async Task HandleShuffleAsync()
  {
    await AudioApi.SetShuffleAsync(!_isShuffleEnabled);
    await RefreshPlaybackStateAsync();
  }

  private async Task HandleRepeatAsync()
  {
    await AudioApi.SetRepeatAsync(_repeatMode);
    await RefreshPlaybackStateAsync();
  }

  private async Task HandleMuteAsync()
  {
    await AudioApi.ToggleMuteAsync(!_isMuted);
    await RefreshPlaybackStateAsync();
  }

  private async Task HandleVolumeChangeAsync(double newVolume)
  {
    _volume = newVolume;
    await AudioApi.SetVolumeAsync((float)newVolume);
  }

  private void OnVolumeChanged(double newVolume)
  {
    _volume = newVolume;
    _ = HandleVolumeChangeAsync(newVolume); // Fire and forget
  }

  public async ValueTask DisposeAsync()
  {
    // Unsubscribe from SignalR events
    HubService.PlaybackStateChanged -= OnPlaybackStateChanged;
    HubService.NowPlayingChanged -= OnNowPlayingChanged;
    HubService.VolumeChanged -= OnVolumeChanged;

    _timer?.Dispose();
    await Task.CompletedTask;
  }
}
